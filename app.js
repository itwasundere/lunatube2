// Generated by CoffeeScript 1.4.0
(function() {
  var explore, fs, gen_cache, io, logins, models, mongo, rooms, schemas, schemas_name, session, session_scheme, spark, utils, yaml,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  yaml = require('js-yaml');

  fs = require('fs');

  utils = require('./lib/utils');

  io = require('socket.io').listen(8081);

  mongo = require('./lib/mongo');

  spark = require('./lib/spark');

  utils = require('./lib/utils');

  schemas_name = __dirname + '/res/schema.yaml';

  schemas = yaml.load(fs.readFileSync(schemas_name, 'utf8'));

  models = spark.spark(schemas);

  mongo.init(schemas);

  spark.store = mongo.store;

  spark.fetch = mongo.fetch;

  spark.query = mongo.query;

  gen_cache = function() {
    var cache;
    cache = {};
    cache._ready = 0;
    cache.explored = function() {
      console.log('k');
      console.log(this._res);
      this._exp = true;
      if (this._res) {
        return this._res();
      }
    };
    cache.bind = function(fn) {
      if (this._exp) {
        fn();
      }
      return this._res = fn;
    };
    cache.lock = function() {
      return this._ready++;
    };
    cache.free = function() {
      return this._ready--;
    };
    cache.freed = function() {
      return this._ready === 0;
    };
    return cache;
  };

  explore = function(id, type, cache) {
    var inst;
    if (!cache) {
      cache = gen_cache();
    }
    if (!id || !type) {
      return;
    }
    if (cache[id]) {
      return;
    }
    cache.lock();
    inst = spark.resolve(id, type);
    inst.bind('ready', function() {
      var k, v, _i, _len, _ref;
      if (!inst._id) {
        return;
      }
      cache[inst._id] = {
        attr: inst._attrs,
        type: inst._type
      };
      _ref = inst._links;
      for (v = _i = 0, _len = _ref.length; _i < _len; v = ++_i) {
        k = _ref[v];
        explore(inst._attr[k], v, cache);
      }
      cache.free();
      if (cache.freed()) {
        return cache.explored();
      }
    });
    return cache;
  };

  session_scheme = spark.gen_class('session', {
    attrs: {
      socket: null,
      user: null,
      room: null
    }
  });

  session = (function(_super) {

    __extends(_Class, _super);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    return _Class;

  })(session_scheme);

  logins = {};

  rooms = new models.roomlist;

  rooms.all();

  io.sockets.on('connection', function(socket) {
    var ip;
    ip = socket.handshake.address;
    if (utils.gate('join', ip)) {
      return;
    }
    socket.on('join', function(data) {
      var cache, cookie, room, sess, user;
      if (!data || !(room = rooms.get(data.roomid))) {
        return;
      }
      cookie = data.cookie;
      if (!(user = logins[cookie])) {
        user = new models.user;
        cookie = utils.random();
        logins[cookie] = user;
      }
      sess = new session({
        user: user,
        room: room,
        socket: socket
      });
      cache = explore(room._id, 'room');
      return cache.bind(function() {
        return socket.emit('joined', {
          cookie: cookie,
          cache: cache,
          roomid: room._id
        });
      });
    });
    socket.on('fetch', function(info) {
      var inst;
      inst = spark.resolve(info.id, info.type);
      return inst.bind('ready', function() {
        return socket.emit('update', {
          attr: inst._attrs,
          hash: info.hash
        });
      });
    });
    return socket.on('store', function(info) {
      var inst;
      inst = spark.resolve(info.id, info.type);
      return inst.bind('ready', function() {
        var k, v, _ref;
        _ref = info.attr;
        for (k in _ref) {
          v = _ref[k];
          inst.set(k, v);
        }
        inst.save();
        return socket.emit('saved', {
          id: inst._id,
          hash: info.hash
        });
      });
    });
  });

}).call(this);
