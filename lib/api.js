// Generated by CoffeeScript 1.4.0
(function() {
  var db, dump_sessions, file, incoming_events, io, models, read, room, session_file, sessions, utils, write;

  file = require('fs');

  read = file.readFileSync;

  write = file.writeFileSync;

  utils = require('./utils');

  db = require('./models');

  models = db.models;

  io = require('socket.io').listen(8081);

  io.set('log level', 0);

  room = db.lookup('3ce6ad4d8a7f57c7');

  session_file = process.cwd() + '/data/sessions.json';

  sessions = JSON.parse(read(session_file, 'utf8'));

  dump_sessions = function() {
    return write(session_file, JSON.stringify(sessions));
  };

  incoming_events = {
    login: function(info) {
      var pass, user;
      user = info.username;
      return pass = info.password;
    },
    append: function(info) {
      var list, pos, target, video, vidid;
      room = db.lookup(info.roomid);
      target = info.target;
      vidid = info.vidid;
      pos = info.pos;
      if (!room) {
        return;
      }
      if (target !== 'playlist' && target !== 'queue') {
        return;
      }
      if (typeof vidid !== 'string' || vidid.length !== 11) {
        return;
      }
      list = room.get(target);
      if (typeof pos !== 'undefined') {
        if (typeof pos !== 'number') {
          return;
        }
        if (pos < 0 || pos > list.length) {
          return;
        }
      }
      video = new models.video({
        vidid: vidid
      });
      return room.get(target).insert(video, pos);
    },
    remove: function(info) {
      room = db.lookup(info.roomid);
      if (!room || !info.vid) {
        return;
      }
      room.get('playlist').remove(info.vid);
      return room.get('queue').remove(info.vid);
    },
    prompt: function(info) {
      room = db.lookup(info.roomid);
      if (!room) {
        return;
      }
      return this.emit('state', room.state());
    },
    playback: function(info) {
      var current;
      room = db.lookup(info.roomid);
      if (!room) {
        return;
      }
      current = room.get('current');
      if (!current) {
        return;
      }
      if (info.state && info.state !== room.get('state')) {
        if (state !== 'playing' && state !== 'paused') {
          return;
        }
        if (state === 'playing') {
          room.play();
        }
        if (state === 'paused') {
          room.pause();
        }
      }
      if (info.time && typeof info.time === 'number') {
        if (info.time > current.get(time)) {
          return;
        }
        return room.seek()(info.time);
      }
    },
    subscribe: function(info) {
      var sock;
      sock = this;
      room = db.lookup(info.roomid);
      if (!room) {
        return;
      }
      room.bind('changed', function() {
        return sock.emit('state', room.state());
      });
      room.get('playlist').bind('changed', function() {
        return sock.emit('playlist', room.get('playlist').json());
      });
      room.get('userlist').bind('changed', function() {
        return sock.emit('userlist', room.get('userlist').json());
      });
      room.get('modlist').bind('changed', function() {
        return sock.emit('modlist', room.get('modlist').json());
      });
      room.get('mutelist').bind('changed', function() {
        return sock.emit('mutelist', room.get('mutelist').json());
      });
      return room.get('userlist').insert(this.user);
    },
    prompt: function(info) {
      return this.emit('obj', db.lookup(info.id));
    },
    disonnect: function() {
      return room.get('userlist').remove(this.user);
    }
  };

  io.sockets.on('connection', function(socket) {
    var cookies, event, fn, session, user;
    cookies = utils.cookie(socket.handshake.headers.cookie || '');
    if (cookies.session && typeof sessions[cookies.session] !== 'undefined') {
      session = cookies.session;
      user = sessions[session];
    } else {
      session = utils.random();
      user = new models.user;
      user.throwaway = true;
      sessions[session] = user;
    }
    socket.user = user;
    for (event in incoming_events) {
      fn = incoming_events[event];
      socket.on(event, fn);
    }
    return socket.emit('session', session);
  });

  module.exports = {
    dump: dump_sessions
  };

}).call(this);
